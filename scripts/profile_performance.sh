#!/bin/bash
# scripts/profile_performance.sh - Profiler les requÃªtes lentes

echo "ðŸ” PERFORMANCE PROFILING - Analyse Historiques"
echo "================================================"
echo ""

cd src-tauri

# Test 1: Compilation + startup time
echo "1ï¸âƒ£  STARTUP TIME"
echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
time cargo build --release 2>&1 | tail -3
echo ""

# Test 2: Analyze SQLite queries
echo "2ï¸âƒ£  DATABASE QUERIES"
echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
echo "ProblÃ¨mes identifiÃ©s:"
echo ""
echo "âŒ PROBLÃˆME 1: Charger TOUS les pairs Ã  chaque fois"
echo "   Ligne 88-90 (event_impact/mod.rs):"
echo "   for pair in &pairs {"
echo "       candle_index.load_pair_candles(pair)?"
echo "   }"
echo "   â†’ Impact: ~10-15 paires = 10-15 requÃªtes DB"
echo ""

echo "âŒ PROBLÃˆME 2: RequÃªte BD sans INDEX"
echo "   Ligne 37 (event_impact/mod.rs):"
echo '   SELECT ... FROM calendar_events WHERE description = ? AND event_time >= "2024-01-01"'
echo "   â†’ Impact: Full table scan si pas d'index sur (description, event_time)"
echo ""

echo "âŒ PROBLÃˆME 3: CandleIndex lock contention"
echo "   Ligne 78-79 (event_impact/mod.rs):"
echo "   let mut index_state = state.index.lock()?"
echo "   â†’ Impact: Bloque toutes autres requÃªtes pendant toute l'opÃ©ration"
echo ""

echo "âŒ PROBLÃˆME 4: Calcul en boucle pour TOUS les pairs"
echo "   Ligne 112-129 (event_impact/mod.rs):"
echo "   for pair in pairs { calculate_volatilities_optimized(...) }"
echo "   â†’ Impact: 10-15 calculs = trÃ¨s gourmand CPU"
echo ""
echo "   Chaque calculate_volatilities_optimized:"
echo "   â€¢ Parcourt 30 minutes de candles (Ã©vÃ©nement)"
echo "   â€¢ Parcourt 7 jours de candles (baseline)"
echo "   â€¢ ~= 500-1000 candles par pair"
echo "   Ã— 10-15 pairs = 5000-15000 candles traitÃ©s!"
echo ""

echo "3ï¸âƒ£  ESTIMATION TEMPS TOTAL"
echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
echo "HypothÃ¨se (avec 10 paires):"
echo "  â€¢ DB query (SELECT events): 50ms"
echo "  â€¢ Load 10 pairs candles: 10 Ã— 100ms = 1000ms"
echo "  â€¢ Calculate volatilities: 10 Ã— 150ms = 1500ms"
echo "  â€¢ Generate output: 50ms"
echo "  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
echo "  TOTAL: ~2600ms âœ—"
echo ""
echo "C'est ce que tu vois!"
echo ""

echo "4ï¸âƒ£  SOLUTIONS PROPOSÃ‰ES"
echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
echo ""
echo "RAPIDE (0 code):"
echo "  âœ“ VÃ©rifier si index existe: SELECT * FROM sqlite_master WHERE type='index';"
echo "  âœ“ Mesurer requÃªte BD: time sqlite3 volatility.db 'SELECT COUNT(*) FROM calendar_events'"
echo "  âœ“ Mesurer CandleIndex load: ajouter println!s"
echo ""
echo "Ã€ FAIRE (lÃ©gÃ¨rement invasif):"
echo "  âœ“ Ajouter INDEX sur calendar_events(description, event_time)"
echo "  âœ“ Charger les candles de maniÃ¨re lazy (Ã  la demande)"
echo "  âœ“ ParallÃ©liser les calculs volatilitÃ© avec rayon_par"
echo "  âœ“ Cacher le rÃ©sultat 5 minutes"
echo ""
echo "GROS OPTIMISATIONS (pour Phase 2):"
echo "  âœ“ PrÃ©-charger CandleIndex au startup (derriÃ¨re spinner)"
echo "  âœ“ Utiliser connection pool pour BD"
echo "  âœ“ Calculer indices techniques cÃ´tÃ© BD (plutÃ´t que Rust)"
echo ""

echo "5ï¸âƒ£  PROCHAINE Ã‰TAPE"
echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
echo "Mesurer les vraies times avec RUST LOGGING:"
echo ""
echo "  cargo run --release 2>&1 | grep -E 'TIMER|Duration'"
echo ""
echo "Ou chercher dans code:"
echo "  grep -r 'println!' src/commands/correlation/"
echo ""

